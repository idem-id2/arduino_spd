# Лучшие практики обработки ошибок в профессиональных программаторах EEPROM

## Основные принципы

### 1. **Debouncing алертов (Подавление дребезга)**
Профессиональные программаторы игнорируют повторяющиеся алерты в короткий период времени (обычно 50-200 мс).

**Проблема:** При быстром подключении/отключении EEPROM приходит множество алертов подряд, что вызывает конфликты.

**Решение:**
- Отслеживать время последнего алерта
- Игнорировать алерты того же типа, если прошло менее 100-200 мс
- Обрабатывать только последний алерт в серии

### 2. **Очереди операций вместо параллельной обработки**
Вместо параллельной обработки алертов используется очередь операций.

**Проблема:** Параллельные операции могут конфликтовать и блокировать друг друга через lock.

**Решение:**
- Использовать `ConcurrentQueue` для алертов
- Обрабатывать алерты последовательно в одном потоке
- Каждая операция завершается перед началом следующей

### 3. **Минимизация времени в критических секциях (lock)**
Операции внутри lock должны быть максимально быстрыми.

**Проблема:** `ScanFull()` сканирует 112 адресов и может занять несколько секунд, блокируя другие потоки.

**Решение:**
- Выполнять долгие операции вне lock
- В lock только быстрые операции (чтение/запись одного байта)
- Использовать кэширование результатов сканирования

### 4. **State Machine (Машина состояний)**
Четкое управление состоянием устройства предотвращает конфликты.

**Состояния:**
- `Idle` - готов к операциям
- `Scanning` - выполняется сканирование
- `Reading` - выполняется чтение
- `Writing` - выполняется запись
- `SettingRswp` - выполняется установка RSWP
- `Disconnected` - устройство отключено

**Преимущества:**
- Предотвращает конфликтующие операции
- Позволяет отменять операции при смене состояния
- Упрощает отладку

### 5. **Таймауты для всех операций**
Каждая операция должна иметь таймаут, чтобы предотвратить зависания.

**Практика:**
- Короткие операции: 1-5 секунд
- Средние операции: 10-30 секунд
- Долгие операции: 60+ секунд с возможностью отмены

### 6. **Retry механизмы с экспоненциальной задержкой**
При временных ошибках (TimeoutException, InvalidDataException) выполнять повторные попытки.

**Стратегия:**
- Первая попытка: немедленно
- Вторая попытка: через 100 мс
- Третья попытка: через 200 мс
- Максимум 3 попытки

### 7. **Изоляция операций**
Каждая операция должна быть независимой и отменяемой.

**Практика:**
- Использовать `CancellationToken` для отмены операций
- Проверять состояние устройства перед каждой операцией
- Быстро выходить из операций при ошибках

### 8. **Разделение критических и некритических операций**
Критические операции (чтение/запись) выполняются синхронно, некритические (сканирование, определение типа) - асинхронно.

**Критические:**
- Чтение/запись SPD данных
- Установка/очистка RSWP
- Операции с высоким напряжением

**Некритические:**
- Полное сканирование I2C шины
- Определение типа памяти
- Проверка RSWP статуса

## Рекомендации для нашего кода

### Текущие проблемы:
1. `ScanFull()` выполняется внутри lock и блокирует другие потоки
2. Нет debouncing для алертов
3. Параллельная обработка алертов может конфликтовать
4. Нет очереди операций

### Предлагаемые улучшения:

1. **Добавить debouncing для алертов:**
```csharp
private DateTime _lastAlertTime = DateTime.MinValue;
private Hardware.Arduino.AlertCodes _lastAlertCode = 0;
private const int AlertDebounceMs = 150; // 150 мс

if (e.Code == _lastAlertCode && 
    (DateTime.Now - _lastAlertTime).TotalMilliseconds < AlertDebounceMs)
{
    // Игнорируем повторяющийся алерт
    return;
}
_lastAlertTime = DateTime.Now;
_lastAlertCode = e.Code;
```

2. **Вынести ScanFull() из lock:**
```csharp
// Быстрые операции в lock
lock (_lock)
{
    // Только быстрые операции
    var addresses = device.Scan(); // Быстрое сканирование SPD адресов
}

// Долгие операции вне lock
var fullAddresses = device.ScanFull(); // Полное сканирование
```

3. **Использовать очередь для алертов:**
```csharp
private readonly ConcurrentQueue<ArduinoAlertEventArgs> _alertQueue = new();
private readonly SemaphoreSlim _alertSemaphore = new(1, 1);

// В HandleAlert:
_alertQueue.Enqueue(e);
_ = Task.Run(async () => await ProcessAlertQueueAsync());

private async Task ProcessAlertQueueAsync()
{
    while (_alertQueue.TryDequeue(out var alert))
    {
        await _alertSemaphore.WaitAsync();
        try
        {
            // Обработка алерта
        }
        finally
        {
            _alertSemaphore.Release();
        }
    }
}
```

4. **Добавить state machine:**
```csharp
private enum DeviceState
{
    Idle,
    Scanning,
    Reading,
    Writing,
    SettingRswp,
    Disconnected
}

private DeviceState _deviceState = DeviceState.Idle;

// Проверка состояния перед операциями
if (_deviceState != DeviceState.Idle && _deviceState != DeviceState.Scanning)
{
    // Операция не может быть выполнена в текущем состоянии
    return;
}
```

## Заключение

Профессиональные программаторы используют комбинацию этих техник для обеспечения надежности и предотвращения зависаний. Ключевые моменты:

1. **Debouncing** - предотвращает обработку ложных алертов
2. **Очереди** - обеспечивают последовательную обработку
3. **Минимизация lock** - предотвращает блокировки
4. **State machine** - управляет состоянием устройства
5. **Таймауты** - предотвращают зависания
6. **Retry** - обрабатывает временные ошибки
7. **Изоляция** - делает операции независимыми

